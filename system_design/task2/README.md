# ТигрБанк - Модуль «Учёт финансов»

## 1. Предметная область

Программа моделирует модуль учёта личных финансов для банковского приложения ТигрБанк.

Пользователь может:
- Создавать, редактировать и удалять **банковские счета** и отслеживать баланс
- Категоризировать доходы и расходы через **категории** (например, «Зарплата», «Кафе», «Здоровье»)
- Фиксировать **финансовые операции** (доход/расход) с привязкой к счёту, категории, дате и описанию
- Получать **аналитику**: разница доходов и расходов за период, группировка по категориям
- **Экспортировать и импортировать** данные в форматах JSON, YAML, CSV
- **Пересчитывать баланс** счёта при обнаружении расхождений (автоматически или вручную)
- **Замерять время** выполнения пользовательских сценариев

### Основные сущности

| Сущность | Поля | Описание |
|----------|------|----------|
| `BankAccount` | id, name, balance | Банковский счёт. Баланс изменяется только через методы `deposit`/`withdraw` |
| `Category` | id, type, name | Категория операции. Тип: INCOME или EXPENSE |
| `Operation` | id, type, bankAccountId, amount, categoryId, date, description | Финансовая операция. Сумма всегда положительная, направление определяется типом |

Все денежные суммы хранятся в `BigDecimal` с фиксированной точностью (2 знака после запятой, округление `HALF_UP`), что исключает ошибки округления, характерные для `double`/`float`.

---

## 2. Code Style

В проекте соблюдается единый стиль кода:

- **Именование:** camelCase для методов и переменных, PascalCase для классов, UPPER_SNAKE_CASE для констант
- **Lombok-аннотации:** `@Getter`, `@RequiredArgsConstructor`, `@Builder`, `@AllArgsConstructor`, `@NoArgsConstructor` - убирают шаблонный код
- **BigDecimal:** создание через `new BigDecimal("...")`, сравнение через `compareTo()`, вывод через `toPlainString()`
- **Валидация:** инкапсулирована в доменных сущностях, private-методы `validateName()`, `validatePositiveAmount()`
- **Исключения:** иерархия от `DomainException`, конкретные подклассы для разных ситуаций

---

## 3. Модульное тестирование

Используются **JUnit 5** и **Mockito**. По 3 ключевых теста на каждый компонент.

### Тесты доменных моделей

| Класс | Что проверяется |
|-------|----------------|
| `BankAccountTest` | Создание с нулевым балансом; deposit/withdraw корректно меняют баланс; снятие больше баланса выбрасывает `LackFundsException` |
| `CategoryTest` | Создание с корректными данными; переименование; валидация пустого имени и null типа |
| `OperationTest` | Создание и приведение суммы к scale=2; отклонение нулевой/отрицательной суммы; отклонение null в обязательных полях |

### Тесты сервисов

| Класс | Что проверяется |
|-------|----------------|
| `BankAccountServiceTest` | Создание сохраняет через репозиторий; получение существующего счёта; получение несуществующего -> `EntityNotFoundException` |
| `CategoryServiceTest` | Создание категории; переименование; получение несуществующей -> ошибка |
| `OperationServiceTest` | Доход увеличивает баланс; расход больше баланса -> ошибка и ничего не сохраняется; удаление расхода возвращает деньги |
| `AnalyticsServiceTest` | Пустой отчёт (всё по нулям); корректный подсчёт доходов/расходов/разницы; группировка по категориям |
| `BalanceRecalculationServiceTest` | Нет расхождения -> 0; есть расхождение -> возвращает разницу; пересчёт исправляет баланс |

### Тест репозитория

| Класс | Что проверяется |
|-------|----------------|
| `BankAccountRepositoryImplTest` | Сохранение и поиск по ID; поиск несуществующего → пустой Optional; удаление работает |

### Запуск тестов

```bash
./gradlew test
```

## 4. Принципы SOLID
### Single Responsibility Principle
Каждый класс имеет ровно одну причину для изменения:

| Класс | Единственная ответственность |
| ----- | ---------------------------- |
| BankAccount | Состояние счета, правила изменения баланса |
| Operation	| Данные операции, валидация инвариантов |
| Category	| Данные категории, валидация |
| BankAccountServiceImpl | CRUD счетов |
| OperationServiceImpl	| CRUD операций + синхронизация баланса |
| AnalyticsServiceImpl	| Аналитика и отчёты |
| BalanceRecalculationServiceImpl |	Пересчёт баланса |
| DataExportServiceImpl	| Экспорт данных |
| DataImportServiceImpl	| Импорт данных |
| TimingServiceImpl	| Замер времени |

### Open/Closed Principle
Система открыта для расширения, закрыта для модификации:

- Аналитика: новый вид отчёта — новый метод в интерфейсе или новый сервис, существующий код не ломается
- Форматы экспорта: добавление XML — новый метод, существующие JSON/YAML/CSV не затрагиваются
### Liskov Substitution Principle
Любая реализация интерфейса полностью взаимозаменяема:

Сервисы работают с интерфейсами и не знают о конкретной реализации. Замена InMemory* на Jpa* не нарушит работу ни одного сервиса.

### Interface Segregation Principle
Интерфейсы узкие и специализированные:

- Отдельные репозитории (BankAccountRepository, CategoryRepository, OperationRepository) вместо одного GenericRepository<T> - OperationServiceImpl не зависит от методов CategoryRepository
- Отдельные сервисы вместо одного «бог-сервиса» - каждый клиент использует только нужный интерфейс
### Dependency Inversion Principle
Высокоуровневые модули зависят от абстракций, а не от реализаций:

Например, Spring DI-контейнер находит реализации по аннотациям @Repository и инжектирует через конструктор.

## 5. DI-контейнер (Spring Boot)

Все зависимости управляются Spring Boot через аннотации — конфигурационный класс не нужен, так как у каждого интерфейса ровно одна реализация.

**Аннотации:**
- `@SpringBootApplication` - включает сканирование пакетов
- `@Repository` - регистрирует бины хранения (`InMemory*Repository`)
- `@Service` - регистрирует бины бизнес-логики (`*ServiceImpl`)
- `@Component` - регистрирует `ConsoleRunner`
- `@RequiredArgsConstructor` (Lombok) - генерирует конструктор, через который Spring инжектирует зависимости

## 6. Проблемы при расширении

### 6.1. Каскадное удаление
При удалении категории операции, ссылающиеся на неё по categoryId, остаются без родительского класса. Аналогично при удалении счета.

Решение при расширении: проверка наличия зависимых записей перед удалением или каскадное удаление.

### 6.2. Конкурентный доступ
Составная операция «прочитать баланс -> изменить -> записать» не атомарна.

Решение при расширении: блокировки.

### 6.3. Валидация связей при импорте
При импорте операция может ссылаться на несуществующий счёт или категорию, если данные неполные или повреждены.

Решение при расширении: валидация целостности ссылок после импорта.

## 7. Почему абстракции улучшают дизайн
### Интерфейсы репозиториев
Без абстракции: сервисы зависят от BankAccountRepositoryImpl. Переход на БД требует изменения каждого сервиса.

С абстракцией: сервисы зависят от BankAccountRepository. Создаём JpaBankAccountRepository - меняем один класс, все сервисы работают без изменений.

Выигрыш: изоляция изменений, тестируемость.

### Интерфейсы сервисов
Без абстракции: ConsoleRunner зависит от OperationServiceImpl. Невозможно подменить без изменения клиента.

С абстракцией: зависимость от OperationService. Можно добавить дополнительную логику, например, логирование - клиент не меняется.

Выигрыш: слабая связанность, расширяемость.

### Разделение сервисов
Без разделения: один FinanceService с большим количеством методами - сложно читать, тестировать, модифицировать.

С разделением: небольшое число сервисов и методов. Изменение аналитики не затрагивает экспорт. Добавление формата экспорта не затрагивает операции.

Выигрыш: независимость изменений, простота тестирования каждого модуля отдельно.

### Иерархия исключений
Без иерархии: везде RuntimeException("сообщение") - невозможно обработать разные ошибки по-разному.

С иерархией: LackFundsException, EntityNotFoundException, InvalidOperationException - точная диагностика, отдельная обработка.

Выигрыш: пользователь получает понятное сообщение, код обработки ошибок чистый.

### Валидация
Без инкапсуляции: валидация разбросана по сервисам, дублируется, может быть забыта.

С инкапсуляцией: BankAccount.deposit() сам проверяет сумму, Operation проверяет все поля в конструкторе. Невозможно создать невалидный объект.

Выигрыш: единая точка валидации.

### 8. Работа с данными из файлов
## Поддерживаемые форматы
| Формат | Экспорт |	Импорт | Библиотека |
| ------ | ------- | --------- | ---------- |
| JSON | + | + | Jackson |
| YAML | + | + | Jackson |
| CSV | + | + | OpenCSV |

### Структура экспортируемых данных
Все форматы содержат одинаковую структуру:

- Список счетов (id, name, balance)
- Список категорий (id, type, name)
- Список операций (id, type, bankAccountId, amount, categoryId, date, description)
JSON/YAML сохраняются в один файл. CSV — в директорию с тремя файлами (accounts.csv, categories.csv, operations.csv).

### Импорт
При импорте сущности восстанавливаются с сохранением оригинальных UUID через конструктор с явным id.
